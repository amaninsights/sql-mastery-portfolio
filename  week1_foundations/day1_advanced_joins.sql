-- Day 1: Advanced JOINs & Set Operations
-- Date: [Tomorrow's date]
-- Goal: Master all JOIN types and set operations
-- Database: practice_db

-- Learning Objectives:
-- 1. Understand all 7 JOIN types
-- 2. Know when to use each JOIN
-- 3. Master set operations (UNION, INTERSECT, EXCEPT)
-- 4. Write production-quality analytical queries

-- ============================================
-- PRACTICE QUERIES START BELOW
-- ============================================

-- Query 1: Show all orders with customer names and cities
-- (Use INNER JOIN)

-- the requirement is the client want the orders details with customer info
-- so we have used orders table as base table as every orders is required so we use inner join which will give us all orders with client info attached
-- we faced one issue client wanted the name of the customers but we don't have that data so to accomodate that we have used customer_id instead which will help to identify the customer
 
Select o.order_id,
       o.order_status,
       o.order_purchase_timestamp,
       c.customer_id,
       c.customer_city
FROM orders o
JOIN customers c
on o.customer_id=c.customer_id;

-- Query 2: Show ALL products, with order information if they were sold
-- (Use LEFT JOIN - you want all products even if not sold)
-- Technical Note:
-- order_items serves as a JUNCTION TABLE in the many-to-many relationship
-- between products and orders. This is necessary because:
-- - One order can contain multiple products
-- - One product can appear in multiple orders
-- - Direct JOIN between products and orders is impossible (no common key)

select 
    p.product_id,
    p.product_category,
    ot.seller_id,
    ot.price,
    ot.freight_value,
    o.customer_id,
    o.order_status,
    o.order_purchase_timestamp
FROM products p 
LEFT JOIN order_items ot 
on p.product_id=ot.product_id
LEFT JOIN orders o 
on o.order_id=ot.order_id
;

-- Query 3: Find products that have NEVER been ordered
-- (Use LEFT JOIN + WHERE NULL pattern)
-- Performance Consideration:
-- Two approaches to anti-join:
-- 1. LEFT JOIN + WHERE NULL: More readable, well-optimized by PostgreSQL
-- 2. NOT EXISTS: Can short-circuit, potentially faster on very large datasets
-- Both perform similarly with proper indexing in PostgreSQL.
-- Using LEFT JOIN for clarity in this case.

Select  p.product_id,
        p.product_category,
        ot.order_id
FROM products p
LEFT JOIN order_items ot 
ON p.product_id=ot.product_id
WHERE ot.order_id is null;
Select  p.product_id,
        p.product_category 
FROM products p
WHERE NOT EXISTS
(SELECT 1 FROM order_items ot 
WHERE ot.product_id=p.product_id);

-- Query 4: Calculate total revenue by customer city
-- (JOIN customers, orders, order_items, then aggregate)
-- Business Context:
-- the customer wants total revenue generated by city 
--
-- Technical Approach:
-- three tables to be used customers,orders,order_items 
-- we will use left join on customers and orders and same for orders and order_items
-- Edge Cases Considered:
-- The total revenue can be generated null as some city might not have generated any revenue 
-- We have to filter out the total revenue which is null
-- we can't directly filter that so we will use CTE to store the values and then query CTE to remove null rows and filter the rows with null values
-- ============================================
-- Query 4: Total Revenue by Customer City
-- ============================================
-- Business Context:
-- Marketing team wants to identify high-revenue cities for targeted campaigns.
-- Revenue includes both product sales and shipping fees.
--
-- Technical Approach:
-- - Use LEFT JOIN to include ALL cities (even those with zero orders)
-- - Chain: customers → orders → order_items
-- - Aggregate revenue per city
-- - Filter out NULL revenue (cities with no orders)
-- - Sort by highest revenue first
--
-- Edge Cases Considered:
-- - Cities with no orders return NULL revenue (filtered in final SELECT)
-- - Used CTE for readability and to separate aggregation from filtering
-- ============================================

WITH city_revenue AS (
    SELECT 
        c.customer_city,
        c.customer_state,
        COUNT(DISTINCT o.order_id) AS total_orders,
        COUNT(DISTINCT c.customer_id) AS unique_customers,
        ROUND(SUM(oi.price), 2) AS product_revenue,
        ROUND(SUM(oi.freight_value), 2) AS shipping_revenue,
        ROUND(SUM(oi.price + oi.freight_value), 2) AS total_revenue
    FROM customers c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY c.customer_city, c.customer_state
)
SELECT 
    customer_city,
    customer_state,
    total_orders,
    unique_customers,
    product_revenue,
    shipping_revenue,
    total_revenue,
    ROUND(total_revenue / NULLIF(unique_customers, 0), 2) AS revenue_per_customer
FROM city_revenue
WHERE total_revenue IS NOT NULL
ORDER BY total_revenue DESC;

-- Query 5: Find customers who ordered Electronics
-- (Multiple JOINs: customers → orders → order_items → products)
-- Business Context:
-- Sales team wants to target Electronics customers for new product launch.
--
-- Technical Approach:
-- - INNER JOIN chain: customers → orders → order_items → products
-- - Filter WHERE product_category = 'Electronics'
-- Edge Cases Considered:
-- - Customer may have multiple orders with Electronics → GROUP BY handles this
-- - Customers who bought OTHER categories are excluded (INNER JOIN behavior)
-- ============================================

SELECT 
    c.customer_id,
    c.customer_city,
    c.customer_state,
    COUNT(DISTINCT o.order_id) AS electronics_orders,
    SUM(oi.price) AS total_electronics_spend
FROM customers c 
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id
WHERE p.product_category = 'Electronics'
GROUP BY c.customer_id, c.customer_city, c.customer_state
ORDER BY total_electronics_spend DESC;



-- Query 6: Show sellers and their total sales, including sellers with zero sales
-- (LEFT JOIN from sellers, then aggregate)
-- ============================================
-- Business Context:
-- Operations team needs to identify underperforming sellers (including those with zero sales)
--
-- Technical Approach:
-- - LEFT JOIN from sellers to order_items (keeps ALL sellers)
-- - Aggregate sales per seller
-- - Use COALESCE to show 0 for sellers with no sales (instead of NULL)
--
-- Edge Cases Considered:
-- - Sellers with no sales return NULL in aggregation → COALESCE converts to 0
-- - Includes seller location for geographic analysis
-- ============================================

SELECT 
    s.seller_id,
    s.seller_city,
    s.seller_state,
    COUNT(oi.order_id) AS total_orders_fulfilled,
    COALESCE(ROUND(SUM(oi.price), 2), 0) AS total_sales,
    COALESCE(ROUND(AVG(oi.price), 2), 0) AS avg_order_value
FROM sellers s 
LEFT JOIN order_items oi ON s.seller_id = oi.seller_id
GROUP BY s.seller_id, s.seller_city, s.seller_state
ORDER BY total_sales DESC;


-- Query 7: Find all products sold in Mumbai
-- (JOIN through: products → order_items → orders → customers, filter by city)
-- ============================================
-- Business Context:
-- Product team wants to understand Mumbai market preferences
--
-- Technical Approach:
-- - INNER JOIN chain: products → order_items → orders → customers
-- - Filter for customer_city = 'Mumbai'
-- - Note: "Sold in Mumbai" = "Bought BY Mumbai customers" (not "Sold BY Mumbai sellers")
--
-- Edge Cases Considered:
-- - Same product may be sold multiple times in Mumbai → Keep duplicates to show demand
-- - If we wanted unique products, we'd use DISTINCT
-- ============================================

SELECT 
    p.product_id,
    p.product_category,
    c.customer_city,
    COUNT(*) AS times_purchased_in_mumbai,
    SUM(oi.price) AS total_revenue_from_mumbai
FROM products p 
INNER JOIN order_items oi ON p.product_id = oi.product_id
INNER JOIN orders o ON oi.order_id = o.order_id
INNER JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_city = 'Mumbai'
GROUP BY p.product_id, p.product_category, c.customer_city
ORDER BY total_revenue_from_mumbai DESC;



-- Query 8: Customers who bought products from multiple different sellers
-- (Self-join or GROUP BY with HAVING)
-- Business Context:
-- Customer team wants to know the customers who brought from different sellers
-- It will help them to identify the customers ordering patterns
-- Technical Approach:
-- We will use 3 tables customers,orders,order_items
-- we will use INNER JOIN for finding customers with mulitple different Sellers
-- Edge Cases Considered:
-- Self Join can't be used as customers table doesn't have any sellers_id column 
-- Self Join can be used using first joining 3 tables customers->orders->order_items inside a CTE and then self join cte 
-- We prefred to use group by and having wihtout CTE and Self join to decrease the query head cost and optimize it 

SELECT 
    c.customer_id,
    c.customer_city,
    c.customer_state,
    COUNT(DISTINCT ot.seller_id) AS unique_sellers,
    COUNT(DISTINCT o.order_id) AS total_orders,
    ROUND(SUM(ot.price), 2) AS total_product_spend,
    ROUND(SUM(ot.freight_value), 2) AS total_shipping_cost,
    ROUND(SUM(ot.price + ot.freight_value), 2) AS total_spend,
    ROUND(AVG(ot.price), 2) AS avg_order_value
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_items ot ON o.order_id = ot.order_id
GROUP BY c.customer_id, c.customer_city, c.customer_state
HAVING COUNT(DISTINCT ot.seller_id) > 1
ORDER BY unique_sellers DESC, total_spend DESC;

-- Query 9: Average review score by product category
-- (JOIN products → order_items → orders → reviews)
-- Business Context:
-- Product team wants average review score by product category
-- Technical Approach:
-- we have used only 3 tables instead of 4 as orders table was not needed as order_items can be directly joined with reviews on common table order_id
-- we have used coalesce for the NULL and round to make it proper formatted
-- Edge Cases Considered:
-- We tried to simplify the joining of tables and removed the orders table from join as it was uncessary abbrev
-- Sometimes there might be no reviews so we might have to consider that and prepare our query accordingly

SELECT 
    p.product_category,
    COUNT(DISTINCT ot.order_id) AS total_orders,
    COUNT(DISTINCT orv.review_id) AS total_reviews,
    COALESCE(ROUND(AVG(orv.review_score), 2), 0) AS avg_review_score,
    COUNT(orv.review_comment_message) AS reviews_with_comments,
    ROUND(100.0 * COUNT(orv.review_comment_message) / NULLIF(COUNT(orv.review_id), 0), 1) AS pct_reviews_with_comments,
    MAX(orv.review_creation_date) AS latest_review_date
FROM products p
LEFT JOIN order_items ot ON p.product_id = ot.product_id
LEFT JOIN order_reviews orv ON ot.order_id = orv.order_id
GROUP BY p.product_category
ORDER BY avg_review_score DESC;

-- Query 10: Find customers who bought Electronics but NOT Books
-- (Use EXCEPT or anti-join pattern)
-- Business Context:
-- Customer Team wants customer data who have brought electronics items and not Books
-- Technical Approach:
-- we have used anti-join pattern where we have used left join on 4 tables [products, orders, order_items, customers]
-- we have fetched the customer_id,city, state and product category and then we have filtered on product category for electronics only abbrev
-- then we have grouped by customer_id and product_category and used count on order_id to find total counts of the orders by customer_id
-- Edge Cases Considered:
-- we can use EXCEPT too but in prod env anti-join looks more appropriate and easy to understand
WITH electronics_customers AS (
    SELECT DISTINCT c.customer_id
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE p.product_category = 'Electronics'
),
books_customers AS (
    SELECT DISTINCT c.customer_id
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE p.product_category = 'Books'
)
SELECT 
    ec.customer_id,
    c.customer_city,
    c.customer_state
FROM electronics_customers ec
LEFT JOIN books_customers bc ON ec.customer_id = bc.customer_id
JOIN customers c ON ec.customer_id = c.customer_id
WHERE bc.customer_id IS NULL;

-- Query 11: Product pairs frequently bought together
-- (Self-join on order_items where same order_id but different products)
-- Business Context:
-- Product team wants to identify which products are frequently purchased together
-- for cross-selling recommendations and bundle offers
-- Technical Approach:
-- - Self-join order_items table on order_id (products in same order)
-- - Use WHERE product_id < product_id to eliminate self-matches and duplicate pairs
-- - GROUP BY the product pair (not order_id) to count across all orders
-- - COUNT how many times each pair appears together
-- - ORDER BY count DESC to show most frequent pairs first
-- Edge Cases Considered:
-- - Prevents product pairing with itself using < comparison
-- - Eliminates duplicate pairs like (A,B) and (B,A) by enforcing order
-- - Groups by product pair only, not individual orders
Select 
    oi1.product_id,
    oi2.product_id,
    COUNT(*) AS times_bought_together
FROM order_items oi1
INNER JOIN order_items oi2
ON oi1.order_id=oi2.order_id
WHERE oi1.product_id < oi2.product_id
GROUP BY oi1.product_id,oi2.product_id
ORDER BY times_bought_together DESC;

-- Query 12: Calculate customer lifetime value by state, including customers with no orders
-- (LEFT JOIN with aggregation and COALESCE for NULLs)
-- Business Context:
-- Finance team needs to analyze Customer Lifetime Value by state for budget allocation.
-- Marketing team will use this to identify high-value states for targeted campaigns.
-- This analysis will help determine which states deserve more marketing investment.

-- Technical Approach:
-- - LEFT JOIN customers to orders to include ALL customers (even those with no orders)
-- - LEFT JOIN orders to order_items to get purchase amounts and shipping costs
-- - GROUP BY customer_state to aggregate all customers within each state
-- - COALESCE with 0 to convert NULL values to zero for customers with no purchases
-- - SUM price + freight_value to calculate total lifetime value per state

-- Edge Cases Considered:
-- - Customers with no orders: LEFT JOIN keeps them, COALESCE shows $0 instead of NULL
-- - States with zero customers: Won't appear in results (acceptable business requirement)
-- - COUNT(DISTINCT order_id) gives actual order count, not item count

SELECT 
    c.customer_state,
    COALESCE(sum(ot.price),0) as total_value,
    COALESCE(sum(ot.freight_value),0) as total_shipping_cost,
    COALESCE(sum(ot.price+ot.freight_value),0) as total_lifetime_value,
    COALESCE(count(distinct ot.order_id),0) as total_orders
FROM customers c 
LEFT JOIN orders o ON c.customer_id=o.customer_id
LEFT JOIN order_items ot ON o.order_id=ot.order_id
Group by c.customer_state
ORDER BY c.customer_state;

-- Query 13: Find "orphan" data - orders without customers OR customers without orders
-- (FULL OUTER JOIN with data quality flags)
-- Business Context:
-- Data Quality team wants the data of the orphan orders where either customer data is not present or order data is not present
-- IT will help them add more quality checks and rectify the issues.
-- Technical Approach:
-- We have used FULL OUTER JOIN to customers and orders table to get all customers and orders ,including unmatched ones.
-- we have applied where condition to identify rows where either side has NULL(indicating orphan data).
-- we have used only customer_id and order_id as these were important columns where null matters.
-- Edge Cases Considered:
-- forgetting to use CASE Statement as it works as data quality flags
-- using wrong join to solve the issue can make it complicated.
-- where condition is necessary as it will be able to find null only join just gives us all rows combination of two tables

Select 
    c.customer_id,
    o.order_id,
    CASE 
        WHEN c.customer_id IS NULL THEN 'ORDER WITHOUT CUSTOMER'
        WHEN o.order_id IS NULL THEN 'CUSTOMER WITHOUT ORDER'
    END AS orphan_type
FROM customers c 
FULL OUTER JOIN orders o ON c.customer_id=o.customer_id
WHERE c.customer_id IS NULL OR o.order_id IS NULL;

-- Query 14: Month-over-month growth in orders by state
-- (Time series with self-join or window functions preview)
-- Business Context:
-- product team needs information about month over month growth by states as they want to see the highest profitability investment.
-- marketing teams wants to know where to campiagn more to get more growth and which has least growth despite the investments.

-- Technical Approach:
-- Multiple approaches shown below: Self-join, Window Functions, and CTE methods
-- Each approach handles the time series comparison differently

-- Edge Cases Considered:
-- - States with no orders in certain months (handled with COALESCE)
-- - Division by zero when calculating growth percentage (NULLIF protection)
-- - First month has no previous data to compare (shows NULL growth)
-- - Date extraction to properly group by year-month periods

-- ============================================
-- APPROACH 1: SELF-JOIN METHOD (Traditional)
-- ============================================

WITH monthly_orders AS (
    SELECT 
        c.customer_state,
        EXTRACT(YEAR FROM o.order_purchase_timestamp) as order_year,
        EXTRACT(MONTH FROM o.order_purchase_timestamp) as order_month,
        COUNT(o.order_id) as monthly_order_count
    FROM orders o
    INNER JOIN customers c ON o.customer_id = c.customer_id
    WHERE o.order_purchase_timestamp IS NOT NULL
    GROUP BY c.customer_state, EXTRACT(YEAR FROM o.order_purchase_timestamp), EXTRACT(MONTH FROM o.order_purchase_timestamp)
)
SELECT 
    current_month.customer_state,
    current_month.order_year,
    current_month.order_month,
    current_month.monthly_order_count as current_orders,
    previous_month.monthly_order_count as previous_orders,
    ROUND(
        ((current_month.monthly_order_count - COALESCE(previous_month.monthly_order_count, 0)) * 100.0 
         / NULLIF(previous_month.monthly_order_count, 0)), 2
    ) as growth_percentage
FROM monthly_orders current_month
LEFT JOIN monthly_orders previous_month 
    ON current_month.customer_state = previous_month.customer_state
    AND (
        (current_month.order_year = previous_month.order_year AND current_month.order_month = previous_month.order_month + 1)
        OR 
        (current_month.order_year = previous_month.order_year + 1 AND current_month.order_month = 1 AND previous_month.order_month = 12)
    )
ORDER BY current_month.customer_state, current_month.order_year, current_month.order_month;

-- ============================================
-- APPROACH 2: WINDOW FUNCTION METHOD (Modern)
-- ============================================

WITH monthly_orders AS (
    SELECT 
        c.customer_state,
        EXTRACT(YEAR FROM o.order_purchase_timestamp) as order_year,
        EXTRACT(MONTH FROM o.order_purchase_timestamp) as order_month,
        COUNT(o.order_id) as monthly_order_count
    FROM orders o
    INNER JOIN customers c ON o.customer_id = c.customer_id
    WHERE o.order_purchase_timestamp IS NOT NULL
    GROUP BY c.customer_state, EXTRACT(YEAR FROM o.order_purchase_timestamp), EXTRACT(MONTH FROM o.order_purchase_timestamp)
)
SELECT 
    customer_state,
    order_year,
    order_month,
    monthly_order_count as current_orders,
    LAG(monthly_order_count, 1) OVER (
        PARTITION BY customer_state 
        ORDER BY order_year, order_month
    ) as previous_orders,
    ROUND(
        ((monthly_order_count - LAG(monthly_order_count, 1) OVER (PARTITION BY customer_state ORDER BY order_year, order_month)) * 100.0
         / NULLIF(LAG(monthly_order_count, 1) OVER (PARTITION BY customer_state ORDER BY order_year, order_month), 0)), 2
    ) as growth_percentage
FROM monthly_orders
ORDER BY customer_state, order_year, order_month;


-- Query 15: Generate a report showing every product-seller combination,
-- marking which actually have sales
-- (CROSS JOIN + LEFT JOIN to actual sales)
-- Business Context:
-- Operations team needs a complete matrix showing all possible product-seller combinations
-- to identify which sellers could potentially sell which products but currently don't.
-- This helps with seller onboarding and product distribution planning.

-- Technical Approach:
-- - CROSS JOIN creates every possible product-seller combination (cartesian product)
-- - LEFT JOIN to order_items on BOTH product_id AND seller_id to find actual sales
-- - COALESCE converts NULL sales to 0 for better reporting
-- - Results show complete matrix with sales amounts (0 = no sales for that combo)

-- Edge Cases Considered:
-- - Product-seller combinations with no sales show 0 instead of NULL
-- - All possible combinations included even if never sold
-- - Handles cases where seller exists but never sold any products

SELECT 
    p.product_id,
    p.product_category,
    s.seller_id,
    s.seller_city,
    COALESCE(SUM(oi.price), 0) as total_sales,
    COUNT(oi.order_id) as orders_count,
    CASE 
        WHEN SUM(oi.price) IS NULL THEN 'No Sales'
        WHEN SUM(oi.price) = 0 THEN 'No Sales'
        ELSE 'Has Sales'
    END as sales_status
FROM products p
CROSS JOIN sellers s
LEFT JOIN order_items oi ON p.product_id = oi.product_id 
                         AND s.seller_id = oi.seller_id
GROUP BY p.product_id, p.product_category, s.seller_id, s.seller_city
ORDER BY p.product_id, s.seller_id;